
\chapter{DynELA programming language}

\startcontents[chapters]
\printmyminitoc[1]\LETTRINE{T}his chapter deals about the \Dynela~programming language.
This language is based on Python 3 and all models must be described
using this formalism. Therefore, this chapter will describe step by
step how to build a Finite Element Model for the \Dynela, using the
Python language.

\section{Introduction}

\subsection{Calling the python interpreter}

After the compilation phase of the code, the \Dynela~can be launch
using the following command:

\textsf{python <'model.py'>}: where model.py is the source Python
3 file defining the \Dynela. The \textsf{model.py }file contains
all the definitions of the Finite Element Model using a Python 3 language
and calling DynELA methods written in \Cpp.

\subsection{Formalism of a DynELA python file}

In order to build a Finite Element Model, it is necessary to import
the \textsf{dnlPython} interpreter from the \textsf{.py} script. Conforming
to this formalism, the minimal piece of Python code to setup a Finite
Element Model is given hereafter.

\begin{PythonListing}
#!/usr/bin/env python3
import dnlPython as dnl # Imports the dnlPython library as dnl
model = dnl.DynELA()    # Creates the main Object
...                     # Set of instructions to build the FE model
                        # and conforming to the DynELA language and Python 3
model.solve()           # Runs the solver
\end{PythonListing}

In the preceding piece of code, line 2 is used to load into memory
the module dnlPython containing the interface to all \Cpp~methods
of the \Dynela~based on the use of the SWIG Python interface. Therefore,
all public methods of the \Dynela~written in \Cpp~can be called
from the Python script to build the FEM model, lanch teh solver, produce
output results... 

In the minimal proposed example, line 3 is used to create an object
of type \textsf{DynELA} (the higher object type in the \Dynela~library)
and instantiate it as the \textsf{model} object\footnote{For the rest of this chapter, we will assume that the name of the
instanciated \textsf{DynELA} object is \textsf{model.}}, while line 6, the solver of the \Dynela~library is called to solve
the problem and produce the results.

As the interpretor of the \Dynela~is based on Python 3 language,
all kind of instructions valid in Python 3 can be used along with
the specific DynELA instructions.

\section{The Kernel library}

\#include \textquotedbl LogFile.h\textquotedbl{}

\#include \textquotedbl MacAddress.h\textquotedbl{}

\#include \textquotedbl Settings.h\textquotedbl{}

\#include \textquotedbl String.h\textquotedbl{}

\#include \textquotedbl System.h\textquotedbl{}

\#include \textquotedbl Timer.h\textquotedbl{}

\#include \textquotedbl Field.h\textquotedbl{}

\section{The Maths library}

\#include \textquotedbl DiscreteFunction.h\textquotedbl{}

\#include \textquotedbl DiscreteFunctionSet.h\textquotedbl{}

\#include \textquotedbl Function.h\textquotedbl{}

\#include \textquotedbl Matrices.h\textquotedbl{}

\#include \textquotedbl Matrix.h\textquotedbl{}

\#include \textquotedbl MatrixDiag.h\textquotedbl{}

\#include \textquotedbl PolynomialFunction.h\textquotedbl{}

\#include \textquotedbl RampFunction.h\textquotedbl{}

\#include \textquotedbl SinusFunction.h\textquotedbl{}

\#include \textquotedbl SymTensor2.h\textquotedbl{}

\#include \textquotedbl Tensor2.h\textquotedbl{}

\#include \textquotedbl Tensor3.h\textquotedbl{}

\#include \textquotedbl Tensor4.h\textquotedbl{}

\#include \textquotedbl Vec3D.h\textquotedbl{}

\#include \textquotedbl Vector.h\textquotedbl{}

\#include \textquotedbl ColorMap.h\textquotedbl{}

\section{Nodes and elements}

All Finite Element Models involves nodes and elements. The very first
part of the model is therefore to create the nodes and the elements
of the structure to setup a FE Model. The \Dynela~library doesn't
include any meshing procedure yet, therefore, it is mandatory to create
all elements and all nodes by hand or using Python loops in case it
can be used. Another way is to use an external meshing program and
convert the output of this program to produce the ad-hoc lines of
Python to describe the elements and the nodes of the model. This has
been used many times by the author, and the Abaqus Finite Element
code, is an efficient way to create the mesh using the .inp text file
generated by the CAE Abaqus program.

\subsection{Definition of the Model}

\subsection{Definition of the nodes}

In the \Dynela, creation of nodes is done by calling the \textsf{DynELA.createNode()}
method. Therefore, a node is created by calling the \textsf{createNode()}
method and giving the new node number and the $x$, $y$ and $z$
coordinates of the new node as presented just below.

\begin{PythonListing}
model.createNode(1, 0.0, 0.0, 0.0)  # Node 1 [0.0, 0.0, 0.0]
model.createNode(2, 1.0, 2.0, -1.0) # Node 2 [1.0, 2.0, -1.0]
\end{PythonListing}

A check of the total number of nodes of the structure can be done
using the \textsf{DynELA.getNodesNumber()} method that returns the
total number of nodes created.

\subsection{Definitions of the elements}

In the \Dynela, creation of elements is done by calling the \textsf{DynELA.createElement()}
method. An element is created by calling the \textsf{createNode()}
method and giving the new element number and the list of nodes defining
the element shape separated by comas and ordered tanks to the element
definition as presented just below. Before creating the very first
element of the structure, it is necessary to define the element shape
using the \textsf{DynELA.setDefaultElement()} method as presented
hereafter.

\begin{PythonListing}
model.setDefaultElement(dnl.Element.ElQua4N2D) # Defines the default element
model.createElement(1, 1, 2, 3, 4)             # Creates element 1 with nodes 1,2,3,4
\end{PythonListing}

The following elements are available in the \Dynela.
\begin{description}
\item [{ElQua4n2D}] : 4 nodes bi-linear 2D quadrilateral element.
\item [{ElQua4NAx}] : 4 nodes bi-linear axisymmetric quadrilateral element.
\item [{ElTri3N2D}] : 3 nodes 2D triangular element.
\item [{ElHex8N3D}] : 8 nodes 3D hexahedral element.
\item [{ElTet4N3D}] : 4 nodes 3D tetrahedral element.
\item [{ElTet10N3D}] : 10 nodes 3D tetrahedral element.
\end{description}
A check of the total number of elements of the structure can be done
using the \textsf{DynELA.getElementsNumber()} method that returns
the total number of elements created.

\subsection{Nodes sets}

Manipulation of nodes, application of boundaries conditions, etc...
is done through the definition of nodes sets. Such nodes sets are
used to group nodes under a \textsf{NodeSet} object for further use.
A \textsf{NodeSet} object contains a reference to a name (a string
use to identify the object), and a list of nodes. Creation of a \textsf{NodeSet}
is done using the \textsf{DynELA.NodeSet()} method that returns an
new \textsf{NodeSet} instance. The \textsf{NodeSet} can be named during
the creation by specifying its name as a string.

\begin{PythonListing}
nset = dnl.NodeSet("NS_All")
\end{PythonListing}

When the \textsf{NodeSet} has been created, one can now define the
list of nodes constituting the \textsf{NodeSet} with the generic \textsf{DynELA.add()}
method with the following formalism \textsf{add(nodeset, start, end,
increment)}. Hereafter are some self explaining examples to illustrate
this process.

\begin{PythonListing}
nset = dnl.NodeSet("NS_All")
model.add(nset, 2)       # Add node number 2 to node set
model.add(nset, 1, 4)    # Add nodes number 1 to 4 to node set
model.add(nset, 1, 4, 2) # Add nodes number 1 and 3 to node set
\end{PythonListing}

\subsection{Element sets}

Application of materials, application of boundaries conditions, etc...
is done through the definition of elements sets. Such elements sets
are used to group elements under an \textsf{ElementSet} object for
further use. An \textsf{ElementSet} object contains a reference to
a name (a string use to identify the object), and a list of elements.
Creation of an \textsf{ElementSet} is done using the \textsf{DynELA.ElementSet()}
method that returns an new \textsf{ElementSet} instance. The \textsf{ElementSet}
can be named during the creation by specifying its name as a string.

\begin{PythonListing}
eset = dnl.ElementSet("ES_All")
\end{PythonListing}

When the \textsf{ElementSet} has been created, one can now define
the list of nodes constituting the \textsf{ElementSet} with the generic
\textsf{DynELA.add()} method with the following formalism \textsf{add(elementset,
start, end, increment)}. Hereafter are some self explaining examples
to illustrate this process.

\begin{PythonListing}
eset = dnl.ElementSet("ES_All")
model.add(eset, 2)       # Add elemeny number 2 to element set
model.add(eset, 1, 4)    # Add elements number 1 to 4 to element set
model.add(eset, 1, 4, 2) # Add elements number 1 and 3 to element set
\end{PythonListing}

\section{Coordinates transformations}

When the mesh has been created, it is always possible to modify the
geometry of the structure by applying some geometrical operations
such as translations, rotations and change of scale. Those operations
apply on a \textsf{NodeSet}.

\subsection{Translations}

One can define a translation of the whole model or a part of the model
by defining a translation vector (an instance of the \Dynela~\textsf{Vec3D})
and apply this translation to the whole structure (without specifying
the \textsf{NodeSet}) or a \textsf{NodeSet} using the \textsf{DynELA.translate()}
method with the following syntax.

\begin{PythonListing}
vector = dnl.Vec3D(1.0, 0.0, 0.0) # Defines the translation vector
model.translate(vector)           # Translates the whole model along [1.0, 0.0, 0.0]
model.translate(vector, nset)     # Translates the NodeSet ns along [1.0, 0.0, 0.0]
\end{PythonListing}

\subsection{Rotations}

One can define a rotation of the whole model or a part of the model
by defining a rotation vector (global axes $\overrightarrow{\ensuremath{x}}$,
$\overrightarrow{y}$, $\overrightarrow{\ensuremath{z}}$ or an instance
of the \Dynela~\textsf{Vec3D}) and an angle $\alpha$ and apply
this rotation to the whole structure (without specifying the \textsf{NodeSet})
or a \textsf{NodeSet} using the \textsf{DynELA.rotate()} method with
the following syntax.

\begin{PythonListing}
axis = dnl.Vec3D(1.0, 1.0, 1.0) # Defines the axis of rotation
model.rotate('X', angle)        # Rotation of the whole structure around X
model.rotate('X', angle, ns)    # Rotation of NodeSet ns around X
model.rotate(axis, angle)       # Rotation of the whole structure around axis
model.rotate(axis, angle, ns)   # Rotation of NodeSet ns around axis
\end{PythonListing}

\subsection{Scaling}

One can define a scaling of the whole model or a part of the model
by defining a scale factor or a scale vector (an instance of the \Dynela~\textsf{Vec3D})
and apply this scaling operation to the whole structure (without specifying
the \textsf{NodeSet}) or a \textsf{NodeSet} using the \textsf{DynELA.scale()}
method with the following syntaxes.

\begin{PythonListing}
vector = dnl.Vec3D(2.0, 1.0, 1.0) # Defines the scale vector
model.scale(value)      # Scales the whole structure by factor value
model.scale(value, ns)  # Scales the NodeSet ns by factor value
model.scale(vector)     # Scales the whole structure by a factor of 2.0 on x
model.scale(vector, ns) # Scales the NodeSet ns by a factor of 2.0 on x
\end{PythonListing}

\section{Materials}

\subsection{General properties}

General properties of materials in Dynela~concerns the general constants
such as Young's modulus, Poisson's ratio, density,... The complete
list of parameters is given hereafter.
\begin{description}
\item [{youngModulus}] : The young modulus $E$ of the material to define
the elastic behaviour of the material.
\item [{poissonRatio}] : The Poisson ratio $\nu$ of the material to define
the elastic behaviour of the material.
\item [{density}] : The density $\rho$ of the material.
\item [{heatCapacity}] : The heat capacity $C_{p}$ of the material.
\item [{taylorQuinney}] : The Taylor-Quinney coefficient $\eta$ defining
the amount of plastic energy converted into heat during a plastic
transformation of the material.
\item [{initialTemperature}] : The initial temperature $T_{0}$ of the
material at the beginning of the computation.
\end{description}
After creating an instance of the object \textsf{dnl.Material}, on
can apply the prescribed values to all those parameters using the
following syntax. 

\begin{PythonListing}
# Creates the material
steel = dnl.Material("Steel")
# Apply all parameters
steel.youngModulus = 206e9
steel.poissonRatio = 0.3
steel.density = 7830
steel.heatCapacity = 46
steel.taylorQuinney = 0.9
steel.initialTemperature = 25
\end{PythonListing}

And, the material can be affected to the elements of the model by
the \textsf{DynELA.add()} method as proposed hereafter.

\begin{PythonListing}
# Creates the material
steel = dnl.Material("Steel")
# Apply all parameters
...
# Affect the material to the element set
model.add(steel, eset)
\end{PythonListing}

\subsection{Johnson-Cook constitutive law}

The Johnson-Cook constitutive law is an hardening law defining the
yield stress $\sigma^{y}(\overline{\varepsilon}^{p},\stackrel{\bullet}{\overline{\varepsilon}^{p}},T)$
by the following equation:

\begin{equation}
\sigma^{y}=\left(A+B\overline{\varepsilon}^{p^{n}}\right)\left[1+C\ln\left(\frac{\stackrel{\bullet}{\overline{\varepsilon}^{p}}}{\stackrel{\bullet}{\overline{\varepsilon}_{0}}}\right)\right]\left[1-\left(\frac{T-T_{0}}{T_{m}-T_{0}}\right)^{m}\right]
\end{equation}
where $\stackrel{\bullet}{\overline{\varepsilon}_{0}}$ is the reference
strain rate, $T_{0}$ and $T_{m}$ are the reference temperature and
the melting temperature of the material respectively and $A$, $B$,
$C$, $n$ and $m$ are the five constitutive flow law parameters.
Therefore, this kind of hardening law can be defined by using the
following piece of code:

\begin{PythonListing}
hardLaw = dnl.JohnsonCookLaw()                       # Hardening law
hardLaw.setParameters(A, B, C, n, m, depsp0, Tm, T0) # Parameters of the law in order
\end{PythonListing}

Once the hardening law has been created, one have to link this hardening
law to a material already defined using the following piece of code:

\begin{PythonListing}
# Creates the material
steel = dnl.Material("Steel")
# Creates the hardening law
hardLaw = dnl.JohnsonCookLaw()
# Attach hardening law to material
steel.setHardeningLaw(hardLaw)
\end{PythonListing}

\section{Boundaries conditions}

\subsection{Restrain boundary condition}

\begin{PythonListing}
# Declaration of a boundary condition for top part
topBC = dnl.BoundaryRestrain('BC_top')
topBC.setValue(0, 1, 1)
model.attachConstantBC(topBC, topNS)
\end{PythonListing}

\subsection{Amplitude}

\begin{PythonListing}
# Declaration of a ramp function to apply the load
ramp = dnl.RampFunction("constantFunction")
ramp.set(dnl.RampFunction.Constant, 0, stopTime)
\end{PythonListing}

\subsection{Constant speed}

\begin{PythonListing}
# Declaration of a boundary condition for top part
topSpeed = dnl.BoundarySpeed()
topSpeed.setValue(displacement, 0, 0)
topSpeed.setFunction(ramp)
model.attachConstantBC(topSpeed, topNS)
\end{PythonListing}

\subsection{Initial speed}

\begin{PythonListing}
# Declaration of a ramp function to apply the load
ramp = dnl.RampFunction("constantFunction")
ramp.set(dnl.RampFunction.Constant, 0, stopTime)
\end{PythonListing}

\section{Fields}

\subsection{Nodal fields}

Nodal fields are defined at nodes and cover types defined in table
\ref{tab:Programming!NodalFields}. Concerning those fields, some
of them are directely defined at nodes, some other are extrapolated
from integration points and transfered to nodes as reported in column
\textsf{loc} of table \ref{tab:Programming!NodalFields}. Concerning
types, \textsf{scalars}, \textsf{vec3D} and \textsf{tensors} are available.
Depending in the type of data, different methods can be used to acces
those data:
\begin{description}
\item [{scalar}] : Direct access to the value as it is unique.
\item [{vec3D}] : Access to all $3$ components of a vec3D using \textsf{nameX},
\textsf{nameY}, \textsf{nameZ} or the norm of the vec3D using \textsf{name}.
\item [{tensor}] : Access to all $9$ components of a tensor using \textsf{nameXX},
\textsf{nameXY},..., \textsf{nameZZ} or the norm of the tensor using
\textsf{name}.
\end{description}
\begin{table}[h]
\begin{center}\begin{tcolorbox}[width=.75\textwidth,myTab,tabularx={c|c|c|c|C}]
name & type & label & loc & description \\ \hline\hline
density & scalar & & IntPt &\\ \hline
displacementIncrement & vec3D & & node & \\ \hline
displacement & vec3D & & node & \\ \hline
energyIncrement & scalar & & IntPt & \\ \hline
energy & scalar & & IntPt & \\ \hline
gammaCumulate & scalar & & IntPt & \\ \hline
gamma & scalar & & IntPt & \\ \hline
internalEnergy & scalar & & IntPt & \\ \hline
mass & scalar & & node & \\ \hline
nodeCoordinate & vec3D & & node & \\ \hline
normal & vec3D & & node & \\ \hline
PlasticStrainInc & tensor & & IntPt & \\ \hline
plasticStrainRate & scalar & & IntPt & \\ \hline
plasticStrain & scalar & & IntPt & \\ \hline
PlasticStrain & tensor & & IntPt & \\ \hline
pressure & scalar & & IntPt & \\ \hline
speedIncrement & vec3D & & node & \\ \hline
speed & vec3D & & node & \\ \hline
StrainInc & tensor & & IntPt & \\ \hline
Strain & tensor & & IntPt & \\ \hline
Stress & tensor & & IntPt & \\ \hline
temperature & scalar & & IntPt & \\ \hline
vonMises & scalar & & IntPt & \\ \hline
yieldStress & scalar & & IntPt & 
\end{tcolorbox}\end{center}\caption{Nodal fields\label{tab:Programming!NodalFields}}
\end{table}


\subsection{Element fields}

Element fields are defined at integration points and cover types defined
in table \ref{tab:Programming!ElementlFields}. Concerning types,
\textsf{scalars}, \textsf{vec3D} and \textsf{tensors} are available.
Depending in the type of data, different methods can be used to acces
those data:
\begin{description}
\item [{scalar}] : Direct access to the value as it is unique.
\item [{vec3D}] : Access to all $3$ components of a vec3D using \textsf{nameX},
\textsf{nameY}, \textsf{nameZ} or the norm of the vec3D using \textsf{name}.
\item [{tensor}] : Access to all $9$ components of a tensor using \textsf{nameXX},
\textsf{nameXY},..., \textsf{nameZZ} or the norm of the tensor using
\textsf{name}.
\end{description}
\begin{table}[h]
\begin{center}\begin{tcolorbox}[width=.75\textwidth,myTab,tabularx={c|c|c|C}]
name & type & label & description \\ \hline\hline
density & scalar & & \\ \hline
gammaCumulate & scalar  & & \\ \hline
gamma & scalar & & \\ \hline
internalEnergy & scalar & & \\ \hline
plasticStrainRate & scalar & & \\ \hline
plasticStrain & scalar & & \\ \hline
PlasticStrain & tensor & & \\ \hline
PlaticStrainInc & tensor & & \\ \hline
pressure & scalar & & \\ \hline
StrainInc & tensor & & \\ \hline
Strain & tensor & & \\ \hline
Stress & tensor & & \\ \hline
temperature & scalar & & \\ \hline
vonMises & scalar & & \\ \hline
yieldStress & scalar & &
\end{tcolorbox}\end{center}\caption{Element fields\label{tab:Programming!ElementlFields}}
\end{table}


\subsection{Global fields}

\begin{table}[h]
\begin{center}\begin{tcolorbox}[width=.75\textwidth,myTab,tabularx={c|c|c|C}]
name & type & label & description \\ \hline\hline
kineticEnergy & scalar & & \\ \hline
realTimeStep & scalar & & \\ \hline
timeStep & scalar & & 
\end{tcolorbox}\end{center}\caption{Global fields\label{tab:Programming!GlobalFields}}
\end{table}


\section{Data Output during computation}

\subsection{Database files}

\subsection{VTK Data files}

\begin{PythonListing}
model.setSaveTimes(0, stopTime, stopTime/nbreSaves)
\end{PythonListing}

\subsection{History files}

\begin{PythonListing}
dtHist = dnl.HistoryFile("dtHistory")
dtHist.setFileName(dnl.String("dt.plot"))
dtHist.add(dnl.Field.timeStep)
dtHist.setSaveTime(stopTime/nbrePoints)
model.add(dtHist)
\end{PythonListing}

\section{Solvers}

\begin{PythonListing}
# Declaration of the explicit solver
solver = dnl.Explicit("Solver")
solver.setTimes(0, stopTime)
solver.setTimeStepSafetyFactor(1.0)
model.add(solver)
\end{PythonListing}

\subsection{Parallel solver}

\begin{PythonListing}
# Parallel solver with two cores
model.parallel.setCores(2)
\end{PythonListing}

\subsection{Solving procedure}

\begin{PythonListing}
# Run the main solver
model.solve()
\end{PythonListing}

\section{Vectorial contourplots}

\subsection{SVG datafile}

\section{Utilities}

\begin{PythonListing}
# Plot the results as curves
import dnlCurves as cu
curves = cu.Curves()
curves.plotFile('Curves.ex')
\end{PythonListing}
